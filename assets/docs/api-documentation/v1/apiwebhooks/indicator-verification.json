{
    "lastReviewedOn": "09 Dec 2024",
    "content": "<h1>Verifying an API webhook indicator</h1>\n<p>\n We have implemented an optional security feature that you can use to ensure the authenticity of the trading indicators received by your webhook. We have signed the request body using RSA. You can retrieve this signature by accessing the 'X-Signature' header of the HTTP request.<br><pre><code>headers:<br>  content-type: application/json<br>  x-signature: KcjizsHo ... pFVgQ==</code></pre><br><strong>Verifying the signature will provide the following assurances:</strong><br><ol><li>  The trading indicator was indeed sent by MarketRaker.</li><li>  The trading indicator was not modified or altered in any way after we sent the HTTP request to you.</li></ol> To authenticate your API webhook indicators, verify the x-signature found in the header of the indicator using your <a href='#/integrations/api-channel'> verification key</a>. This ensures the indicator's authenticity and integrity.\n</p>\n<ol>\n  <li>\n    <strong>Items needed for verification:</strong>\n    <ul>\n      <li>Relevant payload as a JSON .</li>\n      <li>The base64 encoded signature to verify found in the indicator's header.</li>\n      <li>Your PEM formatted <a href='#/integrations/api-channel'> verification key</a>.</li>\n    </ul>\n  </li>\n  <li>\n    <strong>Examples:</strong> Below is an example of a function that can be used to verify indicators followed by the a PEM formatted verification key.\n  <br><b>  Indicator Verifying Function:</b><br><pre><code>from cryptography.hazmat.primitives import serialization, hashes<br>from cryptography.hazmat.primitives.asymmetric import padding<br>from cryptography.hazmat.backends import default_backend<br>from cryptography.exceptions import InvalidSignature<br>import base64<br>import json<br><br>def verify_signature(payload: json, signature: str, public_key_str: str)-> bool:<br>    '''<br>    Verifies the signature of a payload.<br><br>    Parameters:<br>    - payload (json): The payload that was signed.<br>    - signature (str): The base64 encoded signature to verify.<br>    - public_key_str (str): The PEM formatted public key string.<br><br>    Returns:<br>    - bool: True if the signature is valid, False otherwise.<br>    '''<br>    try:<br>        payload_bytes: bytes = payload.encode('utf-8')<br>        signature_bytes: bytes = base64.b64decode(signature.encode('utf-8'))<br><br>        public_key = serialization.load_pem_public_key(<br>            public_key_str.encode('utf-8'), backend=default_backend()<br>        )<br><br>        public_key.verify(<br>            signature_bytes,<br>            payload_bytes,<br>            padding.PSS(<br>                mgf=padding.MGF1(hashes.SHA256()),<br>                salt_length=padding.PSS.MAX_LENGTH,<br>            ),<br>            hashes.SHA256(),<br>        )<br>        return True<br>    except InvalidSignature:<br>        return False<br>    except Exception as e:<br>        print(f'An error occurred during signature verification: {e}')<br>        return False</code></pre>\n  <br><b> Example of PEM formatted Verification Key:</b><br>  -----BEGIN PUBLIC KEY-----\\n...hkiG9w0BAQeFAA...\\n-----END PUBLIC KEY-----\n</li>\n  \n</ol>",
    "i18n_content": "docs_nav_tree.api_documentation.v1.apiwebhooks.content"
}